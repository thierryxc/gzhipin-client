# 智联招聘项目总结

## 1. 项目开发准备
    1). 项目描述: 整体业务功能/功能模块/主体的技术/开发模式
    2). 技术选型: 数据展现/用户交互/组件化, 后端, 前后台交互, 模块化, 项目构建/工程化, 其它
    3). API接口: 接口的4个组成部分, 接口文档, 对/调/测接口

## 2. git管理项目的常用操作
    1). 创建本地仓库
        创建.gitignore配置文件
        git init：在本地文件夹创建新的git仓库
        git add *：提交到暂存区
        git commit -m "xxx"：实际提交改动
    2). 创建github远程仓库
        New Repository
        指定名称
        创建
    3). 将本地仓库推送到远程仓库
        git remote add origin https://github.com/zxfjd3g/170612_JSAdvance.git 关联远程仓库
        git push origin master：提交到远程仓库
    
    4). push本地的更新 
        git add *
        git commit -m "xxx"
        git push origin master
    
    5). pull远程的更新
            git pull origin master
            
    6). 克隆github上的项目:
        git clone https://github.com/zxfjd3g/xxx.git

## 3. 搭建项目
    1). 使用create-react-app脚手架创建模板项目(工程化)
    2). 引入antd-mobile, 并实现按需打包和自定义主题
    3). 引入react-router-dom(v4): 
        HashRouter/Route/Switch
        history: push()/replace()
    4). 引入redux
        redux/react-redux/redux-thunk
        redux: createStore()/combineReducers()/applyMiddleware()
        react-redux: <Provider store={store}> / connect()(Xxx)
        4个重要模块: reducers/store/actions/action-types
---

### react-router-dom

#### 几个概念
* react-router React Router 核心
* react-router-dom 用于 DOM 绑定的 React Router
* react-router-native 用于 React Native 的 React Router
* react-router-redux React Router 和 Redux 的集成
* react-router-config 静态路由配置的小助手

在web app中只需要引入**react-router-dom**

#### HashRouter和BrowserRouter

##### HashRouter 

使用HashRouter时url中会有个#，例如localhost:3000/#，它是通过hash值来对路由进行控制。

##### BrowserRouter

它的原理是使用HTML5 history API (pushState, replaceState, popState)来使你的内容随着url动态改变的，没有#。

#### Route

Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性,exact控制匹配到/路径时不会再继续向下匹配，path标识路由的路径，component表示路径对应显示的组件。

#### Link和NavLink的选择
两者都是可以控制路由跳转的，不同点是NavLink的api更多，更加满足需求。

##### Link
主要api是to，to可以接受string或者一个object，来控制url。

##### NavLink
它可以为当前选中的路由设置类名、样式以及回调函数等。

#### Switch
只渲染出第一个与当前访问地址匹配的`<Route>`或`<Redirect>`。

思考如下代码，如果你访问 `/about`，那么组件` About` `User ` `Nomatch` 都将被渲染出来，因为他们对应的路由与访问的地址 /about 匹配。这显然不是我们想要的，我们只想渲染出第一个匹配的路由就可以了，于是 `<Switch>` 应运而生！

        <Route path="/about" component={About}/>
        <Route path="/:user" component={User}/>
        <Route component={NoMatch}/> 

#### 对象和方法

##### history

* length: number 浏览历史堆栈中的条目数
* action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP
* location: object 当前访问地址信息组成的对象，具有如下属性：
* pathname: string URL路径
* search: string URL中的查询字符串
* hash: string URL的 hash 片段
* state: string 例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state 只有在 browser 和 memory history 有效。
* push(path, [state]) 在历史堆栈信息里加入一个新条目。
* replace(path, [state]) 在历史堆栈信息里替换掉当前的条目
* go(n) 将 history 堆栈中的指针向前移动 n。
* goBack() 等同于 go(-1)
* goForward 等同于 go(1)
* block(prompt) 阻止跳转

##### location

location 是指你当前的位置，将要去的位置，或是之前所在的位置。
location 对象不会发生改变，因此可以在生命周期的回调函数中使用 location 对象来查看当前页面的访问地址是否发生改变。这种技巧在获取远程数据以及使用动画时非常有用。

##### match

match 对象包含了 `<Route path>` 如何与 `URL` 匹配的信息，具有以下属性：
* params: object 路径参数，通过解析` URL `中的动态部分获得键值对
* isExact: bool 为 true 时，整个` URL` 都需要匹配
* path: string 用来匹配的路径模式，用于创建嵌套的`<Route>`
* url: string `URL` 匹配的部分，用于嵌套的` <Link>`

---

### redux

#### 设计思想  

* Web 应用是一个状态机，视图与状态是一一对应的。
* 所有的状态，保存在一个对象里面。

#### 基本概念

* Store：Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。
* State：Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。
* Action：State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。Action 是一个对象。其中的**type**属性是必须的，表示 Action 的名称。可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。
* Action Creator：View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。
* store.dispatch()：View 发出 Action 的唯一方法。
* Reducer：Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。store.dispatch方法会触发 Reducer 的自动执行。为此，**Store** 需要知道 **Reducer** 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。
* Reducer是**纯函数**，可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象.

#### 中间件（主要用于异步action）

##### 中间件的概念

中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。

##### applyMiddlewares()

Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行.所有中间件被放进了一个数组，然后嵌套执行，最后执行store.dispatch。可中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法。

##### 异步操作的基本思路

同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。
* 操作发起时的 Action
* 操作成功时的 Action
* 操作失败时的 Action

所以，在开始处理异步时，送出一个 Action，触发 State 更新为"正在操作"状态，View 重新渲染；操作结束后，再送出一个 Action，触发 State 更新为"操作结束"状态，View 再一次重新渲染

##### redux-thunk

异步操作的redux-thunk解决方案是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch

##### connect()

React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。
connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。

##### Provider

React-Redux 提供Provider组件，可以让容器组件拿到state。
Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。

## 4. 登陆/注册界面
    1). 创建3个1级路由: main/login/register
    2). 完成登陆/注册的静态组件
        antd组件: NavBar/WingBlank/WhiteSpace/List/InputItem/Radio/Button
        路由跳转: this.props.history.replace('/login')
        收集表单输入数据: state/onChange/变量属性名

--- 

### js-cookie

#### 什么是 Cookie？

Cookie 是一些数据, 存储于你电脑上的文本文件中。
当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。
Cookie 的作用就是用于解决 "如何记录客户端的用户信息":
* 当用户访问 web 页面时，他的名字可以记录在 cookie 中。
* 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。
Cookie 以名/值对形式存储，如下所示:
        `username=John Doe`
当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。

#### js-cookie基础用法

        Cookies.set('name', 'value');
        Cookies.set('name', 'value', { expires: 7 });
        Cookies.get('name'); // => 'value'
        Cookies.get(); // => { name: 'value' }读取所有cookie
        Cookies.remove('name');


## 5. 实现简单后台
    1). 使用webstorm创建基于node+express的后台应用
    2). 根据需求编写后台路由
    3). 使用postman测试后台接口
    4). 使用nodemon实现后台应用的自动重启动
    5). 路由回调函数的3步: 读取请求参数/处理/返回响应数据

### express

#### express.router()中间件
就是一个单独的路由系统，写好后直接给到express，模块化。
app.use使用中间件，将其安装到应用中。

#### 路由参数
路径参数是命名的 URL 段，用于捕获在 URL 中的位置指定的值。命名段以冒号为前缀，然后是名称（例如/:your_parameter_name/。捕获的值，使用参数名称作为键，存在 req.params对象中（例如req.params.your_parameter_name）。

例如，考虑一个编码的URL，其中包含有关用户和书本的信息：http://localhost:3000/users/34/books/8989。我们可以使用userId 和bookId 路径参数，提取如下所示的信息：

        app.get('/users/:userId/books/:bookId', function (req, res) {
        // Access userId via: req.params.userId
        // Access bookId via: req.params.bookId
        res.send(req.params);
        })

## 5. 使用mongoose操作数据库
    1). 连接数据库
    2). 定义schema和Model
    3). 通过Model函数对象或Model的实例的方法对集合数据进行CRUD操作

---
### Mongoose
Mongoose是一个MongoDB对象建模工具，用于在异步环境中工作。

#### 连接到 MongoDB

        //Import the mongoose module
        var mongoose = require('mongoose');

        //Set up default mongoose connection
        var mongoDB = 'mongodb://127.0.0.1/my_database';
        mongoose.connect(mongoDB);
        // Get Mongoose to use the global promise library
        mongoose.Promise = global.Promise;
        //Get the default connection
        var db = mongoose.connection;

        //Bind connection to error event (to get notification of connection errors)
        db.on('error', console.error.bind(console, 'MongoDB connection error:'));

#### 模型使用Schema接口进行定义。 
Schema 允许您定义存储在每个文档中的字段，及其验证要求和默认值。

        //Require Mongoose
        var mongoose = require('mongoose');

        //Define a schema
        var Schema = mongoose.Schema;

        var SomeModelSchema = new Schema({
            a_string: String,
            a_date: Date
        });

#### 创建模型
使用mongoose.model() 方法从纲要创建模型。

        // Define schema
        var Schema = mongoose.Schema;

        var SomeModelSchema = new Schema({
            a_string: String,
            a_date: Date
        });

        // Compile model from schema
        var SomeModel = mongoose.model('SomeModel', SomeModelSchema );
第一个参数，是将为模型创建的集合的单数名称（Mongoose将为上面的SomeModel模型，创建数据库集合），第二个参数，是您要在创建模型时使用的纲要Shema。

#### 创建和修改文档
要创建记录，您可以定义模型的实例，然后调用save()。下面的例子假设，SomeModel 是我们从纲要创建的模型（带有单一字段 “name” ）。

        // Create an instance of model SomeModel
        var awesome_instance = new SomeModel({ name: 'awesome' });

        // Save the new model instance, passing a callback
        awesome_instance.save(function (err) {
        if (err) return handleError(err);
        // saved!
        });
创建记录（以及更新，删除和查询）是异步操作 — 您提供在操作完成时调用的回调。API使用错误优先参数约定，因此回调的第一个参数将始终为错误值（或null）。如果API返回一些结果，则将作为第二个参数提供。

您还可以使用create()，同时定义模型实例，并保存模型实例。回调将为第一个参数返回错误，为第二个参数返回新创建的模型实例。

        SomeModel.create({ name: 'also_awesome' }, function (err, awesome_instance) {
        if (err) return handleError(err);
        // saved!
        });
每个模型都有一个关联的连接（当您使用 mongoose.model()时，这将成为默认连接）。您创建一个新连接并调用.model()，以在另一个数据库上创建文档。您可以使用点语法访问此新记录中的字段，并更改值。您必须调用 save() 或 update() ，将修改的值存回数据库。

        // Access model field values using dot notation
        console.log(awesome_instance.name); //should log 'also_awesome'

        // Change record by modifying the fields, then calling save().
        awesome_instance.name="New cool name";
        awesome_instance.save(function (err) {
        if (err) return handleError(err); // saved!
        });

#### 寻找纪录
可以使用查询方法搜索记录，将查询条件指定为 JSON 文档。下面的代码片段，显示了如何在数据库中，找到所有参加网球运动的运动员，只返回运动员姓名和年龄的字段。这里我们只指定一个匹配的字段（运动），但您可以添加更多条件，指定正则表达式标准，或完全删除条件以返回所有运动员。

        var Athlete = mongoose.model('Athlete', yourSchema);

        // find all athletes who play tennis, selecting the 'name' and 'age' fields
        Athlete.find({ 'sport': 'Tennis' }, 'name age', function (err, athletes) {
        if (err) return handleError(err);
        // 'athletes' contains the list of athletes that match the criteria.
        })
如果您指定回调，如上所示，查询将立即执行。搜索完成后将调用回调。

注意: Mongoose中的所有回调，都使用此回调模式callback(error, result)。如果执行查询时发生错误，错误参数error将包含错误文档，并且结果result将为null。如果查询成功，则error参数将为null，并且结果result 将被填充到查询结果。

如果您未指定回调，则API将返回Query类型的变量。您可以使用此查询对象来构建查询，然后稍后使用exec()方法执行（使用回调）。

        // find all athletes that play tennis
        var query = Athlete.find({ 'sport': 'Tennis' });

        // selecting the 'name' and 'age' fields
        query.select('name age');

        // limit our results to 5 items
        query.limit(5);

        // sort by age
        query.sort({ age: -1 });

        // execute the query at a later time
        query.exec(function (err, athletes) {
        if (err) return handleError(err);
        // athletes contains an ordered list of 5 athletes who play Tennis
        })
上面我们在find()方法中，定义了查询条件。我们也可以使用

where()函数来执行此操作，并且我们可以使用点运算符（ . ）将查询的所有部分链接在一起，而不是分别添加它们。

下面的代码片段，与我们上面的查询相同，并有年龄的附加条件。

        Athlete.
        find().
        where('sport').equals('Tennis').
        where('age').gt(17).lt(50).  //Additional where query
        limit(5).
        sort({ age: -1 }).
        select('name age').
        exec(callback); // where callback is the name of our callback function.
find() 方法获取所有匹配的记录，但通常你只想获得一个匹配。以下方法可以查询单个记录：
findById():  用指定的 id 查找文档（每个文档都有一个唯一的id）。
findOne(): 查找与指定条件匹配的单个文档。
findByIdAndRemove(), findByIdAndUpdate(), findOneAndRemove(), findOneAndUpdate(): 通过 id 或条件查找单个文档，并更新或删除它。这些是用于更新和删除记录的有用便利功能。
